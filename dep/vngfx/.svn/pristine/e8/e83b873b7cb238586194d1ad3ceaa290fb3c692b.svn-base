//
//  vnUIScrollBar.cpp
//  vngfx
//
//  Created by Wayne on 13-12-23.
//  Copyright (c) 2013 viichi.com. All rights reserved.
//

#include "vnUIScrollBar.h"

_vn_begin

UIScrollBar::UIScrollBar()
: m_style(kST_Default)
, m_bkgColor(color_t::kWhite)
, m_bkgPicture(vnnew UIRenderPictureEmpty())
, m_sliderColor(color_t::kWhite)
, m_sliderPicture(vnnew UIRenderPicture0())
, m_sliderDirty(false)
, m_sliderUnit(1)
, m_sliderRange(100)
, m_sliderPos(0)
, m_sliderSize(50) {
	
}

UIScrollBar::UIScrollBar(const UIScrollBar &other)
: UIElement(other)
, m_style(other.m_style)
, m_bkgColor(other.m_bkgColor)
, m_bkgPicture(other.m_bkgPicture->clone())
, m_sliderColor(other.m_sliderColor)
, m_sliderPicture(other.m_sliderPicture->clone())
, m_sliderRect(other.m_sliderRect)
, m_sliderDirty(other.m_sliderDirty)
, m_sliderPos(other.m_sliderPos)
, m_sliderSize(other.m_sliderSize)
, m_sliderRange(other.m_sliderRange)
, m_sliderUnit(other.m_sliderUnit) {
	
}

UIScrollBar * UIScrollBar::clone() const {
	return vnnew UIScrollBar(*this);
}

void UIScrollBar::setSliderPosition(f32 position) {
	if (position < 0) {
		position = 0;
	} else if (position > m_sliderRange) {
		position = m_sliderRange;
	}
	if (m_sliderPos != position) {
		m_sliderPos = position;
		m_sliderDirty = true;
	}
}

f32 UIScrollBar::getSliderPosition() const {
	return m_sliderPos;
}

void UIScrollBar::setSliderRange(f32 range)  {
	if (m_sliderRange != range) {
		m_sliderRange = range;
		m_sliderDirty = true;
	}
}

f32 UIScrollBar::getSliderRange() const {
	return m_sliderRange;
}

void UIScrollBar::setSliderSize(f32 size) {
	if (m_sliderSize != size) {
		m_sliderSize = size;
		m_sliderDirty = true;
	}
}

f32 UIScrollBar::getSliderSize() const {
	return m_sliderSize;
}

void UIScrollBar::setSliderUnit(f32 unit) {
	m_sliderUnit = unit;
}

f32 UIScrollBar::getSliderUnit() const {
	return m_sliderUnit;
}

void UIScrollBar::init(const TreeDataObject *object, UIFactory::ElementMap &namedElements) {
	UIElement::init(object, namedElements);
	m_style = (ScrollType)object->queryAttributeInteger("style");
	
	m_bkgColor.convertFromBGRA(object->queryAttributeInteger("bkg_color", m_bkgColor.convertToBGRA()));
	m_sliderColor.convertFromBGRA(object->queryAttributeInteger("slider_color", m_sliderColor.convertToBGRA()));
	const TreeDataObject *tdobj = object->queryAttributeObject("bkg_image");
	UIRenderPicture *pic = 0;
	if (tdobj) {
		pic = UIFactory::instance().createRenderPicture(tdobj);
	}
	if (pic) {
		m_bkgPicture = pic;
	}
	tdobj = object->queryAttributeObject("slider_image");
	pic = 0;
	if (tdobj) {
		pic = UIFactory::instance().createRenderPicture(tdobj);
	}
	if (pic) {
		m_sliderPicture = pic;
	}
}

void UIScrollBar::slide(f32 delta) {
	setSliderPosition(m_sliderPos - delta * m_sliderUnit);
}

void UIScrollBar::onMouseWheel(const vector2f &pos, const vector2f &delta) {
	if (m_style == kST_Horizontal) {
		slide(delta.x);
	} else {
		slide(delta.y);
	}
}

void UIScrollBar::_onBoundingBoxUpdated() {
	m_sliderDirty = true;
	m_bkgPicture->setLocation(m_boundingBox);
}

void UIScrollBar::_onUpdate(f32 deltaTime) {
	if (m_sliderDirty) {
		m_sliderDirty = false;
		vector2f std_size = m_sliderPicture->calculateMinimumSize();
		vector2f size = m_boundingBox.size();
		if (m_style == kST_Horizontal) {
			m_sliderRect.min_corner.y = m_boundingBox.min_corner.y;
			m_sliderRect.max_corner.y = m_boundingBox.max_corner.y;
			size.x -= std_size.x;
			f32 slider = m_sliderSize / m_sliderRange * size.x;
			size.x -= slider;
			f32 pos = m_sliderPos / m_sliderRange * size.x;
			if (pos < 0) {
				slider += pos;
				pos = 0;
			} else if (pos > size.x) {
				slider -= pos - size.x;
				pos = size.x;
			}
			if (slider < 0) {
				slider = 0;
			}
			m_sliderRect.min_corner.x = m_boundingBox.min_corner.x + pos;
			m_sliderRect.max_corner.x = m_sliderRect.min_corner.x + std_size.x + slider;
		} else {
			m_sliderRect.min_corner.x = m_boundingBox.min_corner.x;
			m_sliderRect.max_corner.x = m_boundingBox.max_corner.x;
			size.y -= std_size.y;
			f32 slider = m_sliderSize / m_sliderRange * size.y;
			size.y -= slider;
			m_sliderRect.min_corner.y = m_sliderPos / m_sliderRange * size.y;
			m_sliderRect.max_corner.y = m_sliderRect.min_corner.y + std_size.y + slider;
			if (m_sliderRect.min_corner.y < m_boundingBox.min_corner.y) {
				m_sliderRect.min_corner.y = m_boundingBox.min_corner.y;
			}
			if (m_sliderRect.max_corner.y > m_boundingBox.max_corner.y) {
				m_sliderRect.max_corner.y = m_boundingBox.max_corner.y;
			}
		}
		m_sliderPicture->setLocation(m_sliderRect);
	}
	m_sliderPicture->update(deltaTime);
	m_sliderPicture->update(deltaTime);
}

void UIScrollBar::_onRender(vn::UIRenderer *renderer) {
	m_bkgPicture->render(renderer, m_bkgColor);
	m_sliderPicture->render(renderer, m_sliderColor);
}

_vn_end