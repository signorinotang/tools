//
//  vnUILocator.cpp
//  vngfx
//
//  Created by Wayne on 13-12-17.
//  Copyright (c) 2013 viichi.com. All rights reserved.
//

#include "vnUILocator.h"
#include "vnUIElement.h"

_vn_begin

UILocator::UILocator(UIElement *owner)
: m_owner(owner) {
	vnassert(owner != 0);
	if (m_owner->m_locator) {
		delete m_owner->m_locator;
	}
	m_owner->m_locator = this;
}

UILocator::UILocator(const UILocator &other, UIElement *owner)
: m_owner(owner)
, m_position(other.m_position)
, m_size(other.m_size)
, m_dirty(other.m_dirty) {
	vnassert(owner != 0);
	if (m_owner->m_locator) {
		delete m_owner->m_locator;
	}
	m_owner->m_locator = this;
}

UILocator::~UILocator() {
	m_owner->m_locator = 0;
}

UILocator * UILocator::clone(UIElement *owner) const {
	return vnnew UILocator(*this, owner);
}

void UILocator::setPosition(const vector2f &position) {
	m_position = position;
	m_dirty = true;
}

const vector2f & UILocator::getPosition() const {
	return m_position;
}

void UILocator::setSize(const vector2f &size) {
	m_size = size;
	m_dirty = true;
}

const vector2f & UILocator::getSize() const {
	return m_size;
}

void UILocator::markDirty() {
	m_dirty = true;
}

void UILocator::cleanDirty() {
	if (m_dirty) {
		m_dirty = false;
		_updateBoundingBox();
	}
}

bool UILocator::isDirty() const {
	return m_dirty;
}

void UILocator::update(f32 deltaTime) {
	_onUpdate(deltaTime);
	cleanDirty();
}

void UILocator::init(const vn::TreeDataObject *object) {
    m_dirty = true;
    m_position.x = object->queryAttributeFloat("x");
    m_position.y = object->queryAttributeFloat("y");
    m_size.x = object->queryAttributeFloat("width");
    m_size.y = object->queryAttributeFloat("height");
}

void UILocator::_onUpdate(f32 deltaTime) {
	
}

void UILocator::_set(const aabox2f &location) {
	m_position = location.min_corner;
	m_size = location.size();
	UIElement *p = m_owner->m_parent;
	if (p) {
		m_position -= p->boundingBox().min_corner;
	}
	m_dirty = false;
}

void UILocator::_updateBoundingBox() {
	UIElement *p = m_owner->m_parent;
	aabox2f box;
	box.min_corner = m_position;
	if (p) {
		box.min_corner += p->boundingBox().min_corner;
	}
	box.max_corner = box.min_corner + m_size;
	_setOwnerBoundingBox(box);
}

void UILocator::_setOwnerBoundingBox(const aabox2f &boundingBox) {
	m_owner->m_boundingBox = boundingBox;
	m_owner->_onBoundingBoxUpdated();
}

_vn_end