//
//  vnTextureManager.cpp
//  vngfx
//
//  Created by Wayne on 13-12-10.
//  Copyright (c) 2013 viichi.com. All rights reserved.
//

#include "vnTextureManager.h"
#include "vnFileManager.h"
#include "vnTexture2D.h"

_vn_begin

namespace internal {
    class TextureManagerDefaultDelegate : public TextureManager::Delegate {
    public:
        virtual bool loadTexture(FileStream &, TexturePtr &) { return false; }
    };
    static TextureManagerDefaultDelegate s_defaultDelegate;
}

TextureManager::TextureManager()
: m_delegate(&internal::s_defaultDelegate) {
    
}

void TextureManager::setDelegate(Delegate *delegate) {
    vnassert(delegate);
    m_delegate = delegate;
}

const TexturePtr & TextureManager::loadTexture(u32 fsId, const c8 *fileName) {
    vnassert(fileName);
    FilePath path(fsId, fileName);
    return loadTexture(path);
}

const TexturePtr & TextureManager::loadTexture(const vn::FilePath &path) {
    static TexturePtr s_null;
    std::pair<TextureMap::iterator, bool> ret = m_textures.insert(std::make_pair(path, s_null));
    if (ret.second) {
        FileStream *pfs = FileManager::instance().open(path);
        if (!pfs) {
            m_textures.erase(ret.first);
            return s_null;
        }
        if (!m_delegate->loadTexture(*pfs, ret.first->second)) {
            pfs->close();
            m_textures.erase(ret.first);
            return s_null;
        }
        pfs->close();
    }
    return ret.first->second;
}

void TextureManager::freeTexture(u32 fsId, const c8 *fileName) {
    freeTexture(FilePath(fsId, fileName));
}

void TextureManager::freeTexture(const FilePath &path) {
    m_textures.erase(path);
}

void TextureManager::freeAllTextures() {
    m_textures.clear();
}

void TextureManager::freeUnusedTextures() {
    for (TextureMap::iterator it = m_textures.begin(); it != m_textures.end(); ) {
        if (it->second.ref_count() == 1) {
            it = m_textures.erase(it);
        } else {
            ++it;
        }
    }
}


_vn_end
